{"ast":null,"code":"export function bfs(grid, startNode, finishNode) {\n  const unvisitedNodes = getAllNodes(grid);\n  const visitedNodes = [];\n\n  while (unvisitedNodes.length != 0) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodes;\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (closestNode === finishNode) return visitedNodes;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisistedNodes) {\n  unvisistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisistedNodes(node, grid) {\n  const unvisistedNodes = getNeighbors(node, grid);\n\n  for (const neighbor of unvisistedNodes) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getNeighbors(grid, node) {\n  let neighbors = [];\n  if (node.row > 0) neighbors.push(grid[node.row - 1][node.col]);\n  if (node.col > 0) neighbors.push(grid[node.row][node.col - 1]);\n  if (node.row < grid.length - 1) neighbors.push(grid[node.row + 1][node.col]);\n  if (node.col < grid[0].length - 1) neighbors.push(grid[node.row][node.col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"sources":["/home/willi/Escritorio/Dev/Pathfinding Visualization/path-finder-visualizer/src/Algorithms/Bfs.js"],"names":["bfs","grid","startNode","finishNode","unvisitedNodes","getAllNodes","visitedNodes","length","sortNodesByDistance","closestNode","shift","isWall","distance","Infinity","isVisited","push","updateUnvisitedNeighbors","unvisistedNodes","sort","nodeA","nodeB","updateUnvisistedNodes","node","getNeighbors","neighbor","previousNode","neighbors","row","col","filter"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;AAC7C,QAAMC,cAAc,GAAGC,WAAW,CAACJ,IAAD,CAAlC;AACA,QAAMK,YAAY,GAAG,EAArB;;AACA,SAAMF,cAAc,CAACG,MAAf,IAAyB,CAA/B,EAAkC;AAC9BC,IAAAA,mBAAmB,CAACJ,cAAD,CAAnB;AACA,UAAMK,WAAW,GAAGL,cAAc,CAACM,KAAf,EAApB;AACA,QAAGD,WAAW,CAACE,MAAf,EAAuB;AACvB,QAAGF,WAAW,CAACG,QAAZ,KAAyBC,QAA5B,EAAsC,OAAOP,YAAP;AACtCG,IAAAA,WAAW,CAACK,SAAZ,GAAwB,IAAxB;AACAR,IAAAA,YAAY,CAACS,IAAb,CAAkBN,WAAlB;AACA,QAAGA,WAAW,KAAKN,UAAnB,EAA+B,OAAOG,YAAP;AAC/BU,IAAAA,wBAAwB,CAACP,WAAD,EAAcR,IAAd,CAAxB;AACH;AACJ;;AAED,SAASO,mBAAT,CAA6BS,eAA7B,EAA8C;AAC1CA,EAAAA,eAAe,CAACC,IAAhB,CAAqB,CAACC,KAAD,EAAQC,KAAR,KAAkBD,KAAK,CAACP,QAAN,GAAiBQ,KAAK,CAACR,QAA9D;AACH;;AAED,SAASS,qBAAT,CAA+BC,IAA/B,EAAqCrB,IAArC,EAA2C;AACvC,QAAMgB,eAAe,GAAGM,YAAY,CAACD,IAAD,EAAOrB,IAAP,CAApC;;AACA,OAAI,MAAMuB,QAAV,IAAsBP,eAAtB,EAAuC;AACnCO,IAAAA,QAAQ,CAACZ,QAAT,GAAoBU,IAAI,CAACV,QAAL,GAAgB,CAApC;AACAY,IAAAA,QAAQ,CAACC,YAAT,GAAwBH,IAAxB;AACH;AACJ;;AAED,SAASC,YAAT,CAAsBtB,IAAtB,EAA4BqB,IAA5B,EAAkC;AAC9B,MAAII,SAAS,GAAG,EAAhB;AACA,MAAGJ,IAAI,CAACK,GAAL,GAAW,CAAd,EAAiBD,SAAS,CAACX,IAAV,CAAed,IAAI,CAACqB,IAAI,CAACK,GAAL,GAAS,CAAV,CAAJ,CAAiBL,IAAI,CAACM,GAAtB,CAAf;AACjB,MAAGN,IAAI,CAACM,GAAL,GAAW,CAAd,EAAiBF,SAAS,CAACX,IAAV,CAAed,IAAI,CAACqB,IAAI,CAACK,GAAN,CAAJ,CAAeL,IAAI,CAACM,GAAL,GAAS,CAAxB,CAAf;AACjB,MAAGN,IAAI,CAACK,GAAL,GAAW1B,IAAI,CAACM,MAAL,GAAc,CAA5B,EAA+BmB,SAAS,CAACX,IAAV,CAAed,IAAI,CAACqB,IAAI,CAACK,GAAL,GAAS,CAAV,CAAJ,CAAiBL,IAAI,CAACM,GAAtB,CAAf;AAC/B,MAAGN,IAAI,CAACM,GAAL,GAAW3B,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,GAAgB,CAA9B,EAAiCmB,SAAS,CAACX,IAAV,CAAed,IAAI,CAACqB,IAAI,CAACK,GAAN,CAAJ,CAAeL,IAAI,CAACM,GAAL,GAAS,CAAxB,CAAf;AACjC,SAAOF,SAAS,CAACG,MAAV,CAAiBL,QAAQ,IAAI,CAACA,QAAQ,CAACV,SAAvC,CAAP;AACH","sourcesContent":["export function bfs(grid, startNode, finishNode) {\n    const unvisitedNodes = getAllNodes(grid);\n    const visitedNodes = [];\n    while(unvisitedNodes.length != 0) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        if(closestNode.isWall) continue;\n        if(closestNode.distance === Infinity) return visitedNodes;\n        closestNode.isVisited = true;\n        visitedNodes.push(closestNode);\n        if(closestNode === finishNode) return visitedNodes;\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisistedNodes) {\n    unvisistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisistedNodes(node, grid) {\n    const unvisistedNodes = getNeighbors(node, grid);\n    for(const neighbor of unvisistedNodes) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getNeighbors(grid, node) {\n    let neighbors = [];\n    if(node.row > 0) neighbors.push(grid[node.row-1][node.col]);\n    if(node.col > 0) neighbors.push(grid[node.row][node.col-1]);\n    if(node.row < grid.length - 1) neighbors.push(grid[node.row+1][node.col]);\n    if(node.col < grid[0].length -1) neighbors.push(grid[node.row][node.col+1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\n"]},"metadata":{},"sourceType":"module"}