{"ast":null,"code":"export function dijkstra(grid, startNode, finishNode) {\n  const unvisistedNodes = getAllNodes(grid);\n  const visitedNodes = [];\n\n  while (unvisistedNodes.length != 0) {\n    sortNodesByDistance(unvisistedNodes);\n    const closestNode = unvisistedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodes;\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (closestNode === finishNode) return visitedNodes;\n    updateUnvisistedNodes(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisistedNodes) {\n  unvisistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisistedNodes(node, grid) {\n  const unvisistedNodes = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisistedNodes) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPath = [];\n  let currentNode = finishNode;\n\n  while (currentNode != null) {\n    nodesInShortestPath.unshift(currentNode);\n    currentNode.previousNode;\n  }\n\n  return nodesInShortestPath;\n}","map":{"version":3,"sources":["/home/willi/Escritorio/Dev/Pathfinding Visualization/path-finder-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","unvisistedNodes","getAllNodes","visitedNodes","length","sortNodesByDistance","closestNode","shift","isWall","distance","Infinity","isVisited","push","updateUnvisistedNodes","sort","nodeA","nodeB","node","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","nodes","getNodesInShortestPathOrder","nodesInShortestPath","currentNode","unshift"],"mappings":"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","sourcesContent":["export function dijkstra(grid, startNode, finishNode) {\n    const unvisistedNodes = getAllNodes(grid);\n    const visitedNodes = [];\n    while(unvisistedNodes.length != 0) {\n        sortNodesByDistance(unvisistedNodes);\n        const closestNode = unvisistedNodes.shift();\n        if(closestNode.isWall) continue;\n        if(closestNode.distance === Infinity) return visitedNodes;\n        closestNode.isVisited = true;\n        visitedNodes.push(closestNode);\n        if(closestNode === finishNode) return visitedNodes;\n        updateUnvisistedNodes(closestNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisistedNodes) {\n    unvisistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisistedNodes(node, grid) {\n    const unvisistedNodes = getUnvisitedNeighbors(node, grid);\n    for(const neighbor of unvisistedNodes) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if(row > 0) neighbors.push(grid[row-1][col]);\n    if(row < grid.length - 1) neighbors.push(grid[row+1][col]);\n    if(col > 0) neighbors.push(grid[row][col-1]);\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col+1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for(const row of grid) {\n        for(const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPath = [];\n    let currentNode = finishNode;\n    while(currentNode != null) {\n        nodesInShortestPath.unshift(currentNode);\n        currentNode.previousNode;\n    }\n    return nodesInShortestPath;\n}\n\n\n\n\n\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}