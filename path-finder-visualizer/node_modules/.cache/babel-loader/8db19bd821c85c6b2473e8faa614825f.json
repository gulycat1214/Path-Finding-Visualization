{"ast":null,"code":"export function bfs(grid, startNode, finishNode) {\n  let queue = [];\n  let visitedNodes = [];\n  startNode.isVisited = true;\n  visitedNodes.push(startNode);\n  queue.push(startNode);\n\n  while (queue.length !== 0) {\n    let node = queue.shift();\n    let neighbors = getNeighbors(grid, node);\n\n    for (let i = 0; i < neighbors.length; i++) {\n      if (neighbors[i].isWall) continue;\n      if (neighbors[i] === finishNode) return visitedNodes;\n      neighbors[i].isVisited = true;\n      visitedNodes.push(neighbors[i]);\n      neighbors[i].distance = node.distance + 1;\n      neighbors[i].previousNode = node;\n      queue.push(neighbors[i]);\n    }\n  }\n}\n\nfunction getNeighbors(grid, node) {\n  let neighbors = [];\n  if (node.row > 0) neighbors.push(grid[node.row - 1][node.col]);\n  if (node.col > 0) neighbors.push(grid[node.row][node.col - 1]);\n  if (node.row < grid.length - 1) neighbors.push(grid[node.row + 1][node.col]);\n  if (node.col < grid[0].length - 1) neighbors.push(grid[node.row][node.col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function getShortestPath(finishNode) {\n  const shortestPath = [];\n  let current = finishNode;\n\n  while (current != null) {\n    shortestPath.unshift(current);\n    current = current.previousNode;\n  }\n\n  return shortestPath;\n}","map":{"version":3,"sources":["/home/willi/Escritorio/Dev/Pathfinding Visualization/path-finder-visualizer/src/Algorithms/Bfs.js"],"names":["bfs","grid","startNode","finishNode","queue","visitedNodes","isVisited","push","length","node","shift","neighbors","getNeighbors","i","isWall","distance","previousNode","row","col","filter","neighbor","getShortestPath","shortestPath","current","unshift"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;AAC7C,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,YAAY,GAAG,EAAnB;AACAH,EAAAA,SAAS,CAACI,SAAV,GAAsB,IAAtB;AACAD,EAAAA,YAAY,CAACE,IAAb,CAAkBL,SAAlB;AACAE,EAAAA,KAAK,CAACG,IAAN,CAAWL,SAAX;;AACA,SAAME,KAAK,CAACI,MAAN,KAAiB,CAAvB,EAA0B;AACtB,QAAIC,IAAI,GAAGL,KAAK,CAACM,KAAN,EAAX;AACA,QAAIC,SAAS,GAAGC,YAAY,CAACX,IAAD,EAAOQ,IAAP,CAA5B;;AACA,SAAI,IAAII,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,SAAS,CAACH,MAA7B,EAAqCK,CAAC,EAAtC,EAA0C;AACtC,UAAGF,SAAS,CAACE,CAAD,CAAT,CAAaC,MAAhB,EAAwB;AACxB,UAAGH,SAAS,CAACE,CAAD,CAAT,KAAiBV,UAApB,EAAgC,OAAOE,YAAP;AAChCM,MAAAA,SAAS,CAACE,CAAD,CAAT,CAAaP,SAAb,GAAyB,IAAzB;AACAD,MAAAA,YAAY,CAACE,IAAb,CAAkBI,SAAS,CAACE,CAAD,CAA3B;AACAF,MAAAA,SAAS,CAACE,CAAD,CAAT,CAAaE,QAAb,GAAwBN,IAAI,CAACM,QAAL,GAAgB,CAAxC;AACAJ,MAAAA,SAAS,CAACE,CAAD,CAAT,CAAaG,YAAb,GAA4BP,IAA5B;AACAL,MAAAA,KAAK,CAACG,IAAN,CAAWI,SAAS,CAACE,CAAD,CAApB;AACH;AAEJ;AACJ;;AAED,SAASD,YAAT,CAAsBX,IAAtB,EAA4BQ,IAA5B,EAAkC;AAC9B,MAAIE,SAAS,GAAG,EAAhB;AACA,MAAGF,IAAI,CAACQ,GAAL,GAAW,CAAd,EAAiBN,SAAS,CAACJ,IAAV,CAAeN,IAAI,CAACQ,IAAI,CAACQ,GAAL,GAAS,CAAV,CAAJ,CAAiBR,IAAI,CAACS,GAAtB,CAAf;AACjB,MAAGT,IAAI,CAACS,GAAL,GAAW,CAAd,EAAiBP,SAAS,CAACJ,IAAV,CAAeN,IAAI,CAACQ,IAAI,CAACQ,GAAN,CAAJ,CAAeR,IAAI,CAACS,GAAL,GAAS,CAAxB,CAAf;AACjB,MAAGT,IAAI,CAACQ,GAAL,GAAWhB,IAAI,CAACO,MAAL,GAAc,CAA5B,EAA+BG,SAAS,CAACJ,IAAV,CAAeN,IAAI,CAACQ,IAAI,CAACQ,GAAL,GAAS,CAAV,CAAJ,CAAiBR,IAAI,CAACS,GAAtB,CAAf;AAC/B,MAAGT,IAAI,CAACS,GAAL,GAAWjB,IAAI,CAAC,CAAD,CAAJ,CAAQO,MAAR,GAAgB,CAA9B,EAAiCG,SAAS,CAACJ,IAAV,CAAeN,IAAI,CAACQ,IAAI,CAACQ,GAAN,CAAJ,CAAeR,IAAI,CAACS,GAAL,GAAS,CAAxB,CAAf;AACjC,SAAOP,SAAS,CAACQ,MAAV,CAAiBC,QAAQ,IAAI,CAACA,QAAQ,CAACd,SAAvC,CAAP;AACH;;AAED,OAAO,SAASe,eAAT,CAAyBlB,UAAzB,EAAqC;AACxC,QAAMmB,YAAY,GAAG,EAArB;AACA,MAAIC,OAAO,GAAGpB,UAAd;;AACA,SAAMoB,OAAO,IAAI,IAAjB,EAAuB;AACnBD,IAAAA,YAAY,CAACE,OAAb,CAAqBD,OAArB;AACAA,IAAAA,OAAO,GAAGA,OAAO,CAACP,YAAlB;AACH;;AACD,SAAOM,YAAP;AACH","sourcesContent":["export function bfs(grid, startNode, finishNode) {\n    let queue = [];\n    let visitedNodes = [];\n    startNode.isVisited = true;\n    visitedNodes.push(startNode);\n    queue.push(startNode);\n    while(queue.length !== 0) {\n        let node = queue.shift();\n        let neighbors = getNeighbors(grid, node);\n        for(let i = 0; i < neighbors.length; i++) {\n            if(neighbors[i].isWall) continue;\n            if(neighbors[i] === finishNode) return visitedNodes;\n            neighbors[i].isVisited = true;\n            visitedNodes.push(neighbors[i]);\n            neighbors[i].distance = node.distance + 1;\n            neighbors[i].previousNode = node;\n            queue.push(neighbors[i]);\n        }\n\n    }\n}\n\nfunction getNeighbors(grid, node) {\n    let neighbors = [];\n    if(node.row > 0) neighbors.push(grid[node.row-1][node.col]);\n    if(node.col > 0) neighbors.push(grid[node.row][node.col-1]);\n    if(node.row < grid.length - 1) neighbors.push(grid[node.row+1][node.col]);\n    if(node.col < grid[0].length -1) neighbors.push(grid[node.row][node.col+1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function getShortestPath(finishNode) {\n    const shortestPath = [];\n    let current = finishNode;\n    while(current != null) {\n        shortestPath.unshift(current);\n        current = current.previousNode;\n    }\n    return shortestPath;\n}"]},"metadata":{},"sourceType":"module"}