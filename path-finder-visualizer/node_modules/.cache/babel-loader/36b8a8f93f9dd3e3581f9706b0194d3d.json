{"ast":null,"code":"export function bfs(grid, startNode, finishNode) {\n  const unvisitedNodes = getAllNodes(grid);\n  const visitedNodes = [];\n\n  while (unvisitedNodes.length != 0) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodes;\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (closestNode === finishNode) return visitedNodes;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisistedNodes) {\n  unvisistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisistedNodes = getNeighbors(node, grid);\n\n  for (const neighbor of unvisistedNodes) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/home/willi/Escritorio/Dev/Pathfinding Visualization/path-finder-visualizer/src/Algorithms/Bfs.js"],"names":["bfs","grid","startNode","finishNode","unvisitedNodes","getAllNodes","visitedNodes","length","sortNodesByDistance","closestNode","shift","isWall","distance","Infinity","isVisited","push","updateUnvisitedNeighbors","unvisistedNodes","sort","nodeA","nodeB","node","getNeighbors","neighbor","previousNode","neighbors","col","row","filter","nodes"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;AAC7C,QAAMC,cAAc,GAAGC,WAAW,CAACJ,IAAD,CAAlC;AACA,QAAMK,YAAY,GAAG,EAArB;;AACA,SAAMF,cAAc,CAACG,MAAf,IAAyB,CAA/B,EAAkC;AAC9BC,IAAAA,mBAAmB,CAACJ,cAAD,CAAnB;AACA,UAAMK,WAAW,GAAGL,cAAc,CAACM,KAAf,EAApB;AACA,QAAGD,WAAW,CAACE,MAAf,EAAuB;AACvB,QAAGF,WAAW,CAACG,QAAZ,KAAyBC,QAA5B,EAAsC,OAAOP,YAAP;AACtCG,IAAAA,WAAW,CAACK,SAAZ,GAAwB,IAAxB;AACAR,IAAAA,YAAY,CAACS,IAAb,CAAkBN,WAAlB;AACA,QAAGA,WAAW,KAAKN,UAAnB,EAA+B,OAAOG,YAAP;AAC/BU,IAAAA,wBAAwB,CAACP,WAAD,EAAcR,IAAd,CAAxB;AACH;AACJ;;AAED,SAASO,mBAAT,CAA6BS,eAA7B,EAA8C;AAC1CA,EAAAA,eAAe,CAACC,IAAhB,CAAqB,CAACC,KAAD,EAAQC,KAAR,KAAkBD,KAAK,CAACP,QAAN,GAAiBQ,KAAK,CAACR,QAA9D;AACH;;AAED,SAASI,wBAAT,CAAkCK,IAAlC,EAAwCpB,IAAxC,EAA8C;AAC1C,QAAMgB,eAAe,GAAGK,YAAY,CAACD,IAAD,EAAOpB,IAAP,CAApC;;AACA,OAAI,MAAMsB,QAAV,IAAsBN,eAAtB,EAAuC;AACnCM,IAAAA,QAAQ,CAACX,QAAT,GAAoBS,IAAI,CAACT,QAAL,GAAgB,CAApC;AACAW,IAAAA,QAAQ,CAACC,YAAT,GAAwBH,IAAxB;AACH;AACJ;;AAED,SAASC,YAAT,CAAsBD,IAAtB,EAA4BpB,IAA5B,EAAkC;AAC9B,QAAMwB,SAAS,GAAG,EAAlB;AACA,QAAM;AAACC,IAAAA,GAAD;AAAMC,IAAAA;AAAN,MAAaN,IAAnB;AACA,MAAGM,GAAG,GAAG,CAAT,EAAYF,SAAS,CAACV,IAAV,CAAed,IAAI,CAAC0B,GAAG,GAAC,CAAL,CAAJ,CAAYD,GAAZ,CAAf;AACZ,MAAGC,GAAG,GAAG1B,IAAI,CAACM,MAAL,GAAc,CAAvB,EAA0BkB,SAAS,CAACV,IAAV,CAAed,IAAI,CAAC0B,GAAG,GAAC,CAAL,CAAJ,CAAYD,GAAZ,CAAf;AAC1B,MAAGA,GAAG,GAAG,CAAT,EAAYD,SAAS,CAACV,IAAV,CAAed,IAAI,CAAC0B,GAAD,CAAJ,CAAUD,GAAG,GAAC,CAAd,CAAf;AACZ,MAAGA,GAAG,GAAGzB,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,GAAiB,CAA1B,EAA6BkB,SAAS,CAACV,IAAV,CAAed,IAAI,CAAC0B,GAAD,CAAJ,CAAUD,GAAG,GAAC,CAAd,CAAf;AAC7B,SAAOD,SAAS,CAACG,MAAV,CAAiBL,QAAQ,IAAI,CAACA,QAAQ,CAACT,SAAvC,CAAP;AACH;;AAED,SAAST,WAAT,CAAqBJ,IAArB,EAA2B;AACvB,QAAM4B,KAAK,GAAG,EAAd;;AACA,OAAI,MAAMF,GAAV,IAAiB1B,IAAjB,EAAuB;AACnB,SAAI,MAAMoB,IAAV,IAAkBM,GAAlB,EAAuB;AACnBE,MAAAA,KAAK,CAACd,IAAN,CAAWM,IAAX;AACH;AACJ;;AACD,SAAOQ,KAAP;AACH","sourcesContent":["export function bfs(grid, startNode, finishNode) {\n    const unvisitedNodes = getAllNodes(grid);\n    const visitedNodes = [];\n    while(unvisitedNodes.length != 0) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        if(closestNode.isWall) continue;\n        if(closestNode.distance === Infinity) return visitedNodes;\n        closestNode.isVisited = true;\n        visitedNodes.push(closestNode);\n        if(closestNode === finishNode) return visitedNodes;\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisistedNodes) {\n    unvisistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisistedNodes = getNeighbors(node, grid);\n    for(const neighbor of unvisistedNodes) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if(row > 0) neighbors.push(grid[row-1][col]);\n    if(row < grid.length - 1) neighbors.push(grid[row+1][col]);\n    if(col > 0) neighbors.push(grid[row][col-1]);\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col+1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for(const row of grid) {\n        for(const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}"]},"metadata":{},"sourceType":"module"}