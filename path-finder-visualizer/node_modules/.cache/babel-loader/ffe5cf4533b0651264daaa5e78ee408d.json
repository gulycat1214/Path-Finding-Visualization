{"ast":null,"code":"// Implementation of DIJKSTRA's ALGORITHM\n// Functionality:\n// - Set all nodes with distance Infinity to initial node\n// - Sort all nodes by distance to initial node and\n//      get the nearest node\n// - Mark this node as visited, increment distance to origin\n// - Get neighbor nodes and sort again\n// - When arriving to final Node, backtrack to find shortest path.\nexport function dijkstra(grid, startNode, finishNode) {\n  const unvisistedNodes = getAllNodes(grid);\n  const visitedNodes = [];\n\n  while (unvisistedNodes.length != 0) {\n    // get nearest node\n    sortNodesByDistance(unvisistedNodes);\n    const closestNode = unvisistedNodes.shift();\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === Infinity) return visitedNodes; // mark as visited\n\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (closestNode === finishNode) return visitedNodes; // update distances + 1\n\n    updateUnvisistedNodes(closestNode, grid);\n  }\n} // sort array of nodes by distance to origin\n\nfunction sortNodesByDistance(unvisistedNodes) {\n  unvisistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n} // update neighbor nodes\n\n\nfunction updateUnvisistedNodes(node, grid) {\n  const unvisitedNodes = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNodes) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPath = [];\n  let currentNode = finishNode;\n\n  while (currentNode != null) {\n    nodesInShortestPath.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPath;\n}","map":{"version":3,"sources":["/home/willi/Escritorio/Dev/Pathfinding Visualization/path-finder-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","unvisistedNodes","getAllNodes","visitedNodes","length","sortNodesByDistance","closestNode","shift","isWall","distance","Infinity","isVisited","push","updateUnvisistedNodes","sort","nodeA","nodeB","node","unvisitedNodes","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","nodes","getNodesInShortestPathOrder","nodesInShortestPath","currentNode","unshift"],"mappings":"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","sourcesContent":["// Implementation of DIJKSTRA's ALGORITHM\n// Functionality:\n// - Set all nodes with distance Infinity to initial node\n// - Sort all nodes by distance to initial node and\n//      get the nearest node\n// - Mark this node as visited, increment distance to origin\n// - Get neighbor nodes and sort again\n// - When arriving to final Node, backtrack to find shortest path.\n\n\nexport function dijkstra(grid, startNode, finishNode) {\n    const unvisistedNodes = getAllNodes(grid);\n    const visitedNodes = [];\n    while(unvisistedNodes.length != 0) {\n        // get nearest node\n        sortNodesByDistance(unvisistedNodes);\n        const closestNode = unvisistedNodes.shift();\n        if(closestNode.isWall) continue;\n        if(closestNode.distance === Infinity) return visitedNodes;\n        // mark as visited\n        closestNode.isVisited = true;\n        visitedNodes.push(closestNode);\n        if(closestNode === finishNode) return visitedNodes;\n        // update distances + 1\n        updateUnvisistedNodes(closestNode, grid);\n    }\n}\n// sort array of nodes by distance to origin\nfunction sortNodesByDistance(unvisistedNodes) {\n    unvisistedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n// update neighbor nodes\nfunction updateUnvisistedNodes(node, grid) {\n    const unvisitedNodes = getUnvisitedNeighbors(node, grid);\n    for(const neighbor of unvisitedNodes) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if(row > 0) neighbors.push(grid[row-1][col]);\n    if(row < grid.length - 1) neighbors.push(grid[row+1][col]);\n    if(col > 0) neighbors.push(grid[row][col-1]);\n    if(col < grid[0].length - 1) neighbors.push(grid[row][col+1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for(const row of grid) {\n        for(const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPath = [];\n    let currentNode = finishNode;\n    while(currentNode != null) {\n        nodesInShortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPath;\n}\n\n\n\n\n\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}